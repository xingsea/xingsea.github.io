[{"content":"let、const 和 var 的详细区别 在 JavaScript 中，变量声明的方式主要有三种：var、let 和 const。它们在作用域、提升、重复声明等方面有显著差异。下面我将详细解释它们的区别。\n1. 作用域 (Scope) var - 函数作用域 (Function Scope) var 声明的变量作用域是函数级的，或者全局的（如果在函数外声明）。\n1 2 3 4 5 6 function varExample() { if (true) { var x = 10; } console.log(x); // 10，因为var是函数作用域 } let 和 const - 块级作用域 (Block Scope) let 和 const 声明的变量作用域是块级的（即 {} 内的范围）。\n1 2 3 4 5 6 7 8 function letExample() { if (true) { let y = 20; const z = 30; } console.log(y); // ReferenceError: y is not defined console.log(z); // ReferenceError: z is not defined } 2. 变量提升 (Hoisting) var - 声明提升，初始化为 undefined 1 2 3 console.log(a); // undefined var a = 5; console.log(a); // 5 等价于：\n1 2 3 4 var a; console.log(a); // undefined a = 5; console.log(a); // 5 let 和 const - 声明提升，但存在暂时性死区 (TDZ) 1 2 console.log(b); // ReferenceError: Cannot access \u0026#39;b\u0026#39; before initialization let b = 10; 3. 重复声明 var - 允许重复声明 1 2 3 var c = 1; var c = 2; // 允许 console.log(c); // 2 let 和 const - 不允许重复声明 1 2 let d = 1; let d = 2; // SyntaxError: Identifier \u0026#39;d\u0026#39; has already been declared 4. 全局作用域行为 var - 成为全局对象属性 1 2 var e = 1; console.log(window.e); // 1 (在浏览器环境中) let 和 const - 不会成为全局对象属性 1 2 let f = 2; console.log(window.f); // undefined 5. 可变性 const - 常量声明 必须初始化 不能重新赋值 但对于对象和数组，内容可以修改 1 2 3 4 5 6 const g = 3; g = 4; // TypeError: Assignment to constant variable const obj = {a: 1}; obj.a = 2; // 允许 obj = {}; // TypeError 6. 实际应用场景 使用 const 的情况 当变量不需要重新赋值时 对象和数组的引用 配置常量 1 2 3 const PI = 3.14159; const COLORS = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; const CONFIG = {apiUrl: \u0026#39;https://api.example.com\u0026#39;}; 使用 let 的情况 循环计数器 需要重新赋值的变量 块级作用域变量 1 2 3 for (let i = 0; i \u0026lt; 5; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 输出 0,1,2,3,4 } 避免使用 var 的情况 现代 JavaScript 开发中 需要块级作用域时 防止变量提升带来的意外行为 7. 特殊注意事项 for 循环中的 var 和 let 1 2 3 4 5 6 7 8 9 // 使用 var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 输出 3,3,3 } // 使用 let for (let j = 0; j \u0026lt; 3; j++) { setTimeout(() =\u0026gt; console.log(j), 100); // 输出 0,1,2 } const 与不可变性 const 只保证变量引用不变，不保证引用的内容不变：\n1 2 3 const arr = [1, 2, 3]; arr.push(4); // 允许 arr = [5, 6]; // TypeError 总结表格 特性 var let const 作用域 函数作用域 块级作用域 块级作用域 变量提升 是 (值为undefined) 是 (TDZ) 是 (TDZ) 重复声明 允许 不允许 不允许 全局属性 成为window属性 不成为window属性 不成为window属性 重新赋值 允许 允许 不允许 必须初始化 否 否 是 最佳实践建议 默认使用 const - 除非你知道变量需要被重新赋值 需要重新赋值时使用 let 避免使用 var - 除非有特殊需求或维护旧代码 注意作用域 - 使用 let 和 const 可以避免许多作用域相关的问题 保持一致性 - 在项目中统一变量声明方式 ","date":"2025-08-15T10:59:18+08:00","permalink":"https://XingSea.github.io/p/letconstvar-%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"let、const、var 的区别"},{"content":"grep 是 Global Regular Expression Print（全局正则表达式打印）的缩写，是 Linux/Unix 系统中一个强大的 文本搜索工具，用于在文件或输入数据中查找匹配特定模式（字符串或正则表达式）的行。\n1. grep 的基本用法 语法： 1 grep [选项] \u0026#34;搜索模式\u0026#34; [文件...] \u0026quot;搜索模式\u0026quot;：可以是普通字符串或正则表达式。 [文件...]：可以是一个或多个文件，如果不指定文件，则从标准输入（如管道 |）读取数据。 示例： (1) 在文件中搜索关键字 1 grep \u0026#34;error\u0026#34; /var/log/syslog 在 /var/log/syslog 中查找包含 \u0026quot;error\u0026quot; 的行。 (2) 忽略大小写（-i） 1 grep -i \u0026#34;warning\u0026#34; /var/log/syslog -i（--ignore-case）忽略大小写，匹配 \u0026quot;warning\u0026quot;、\u0026quot;WARNING\u0026quot;、\u0026quot;Warning\u0026quot; 等。 (3) 显示行号（-n） 1 grep -n \u0026#34;root\u0026#34; /etc/passwd -n（--line-number）显示匹配行的行号。 (4) 反向匹配（-v） 1 grep -v \u0026#34;success\u0026#34; /var/log/app.log -v（--invert-match）显示 不包含 \u0026quot;success\u0026quot; 的行。 (5) 统计匹配行数（-c） 1 grep -c \u0026#34;404\u0026#34; /var/log/nginx/access.log -c（--count）统计匹配 \u0026quot;404\u0026quot; 的行数。 2. grep 结合正则表达式 grep 默认支持 基本正则表达式（BRE），使用 -E 可启用 扩展正则表达式（ERE）。\n常用正则表达式示例： 模式 说明 ^word 匹配以 word 开头的行 word$ 匹配以 word 结尾的行 [abc] 匹配 a、b 或 c [0-9] 匹配任意数字 a.*b 匹配 a 开头、b 结尾的字符串（中间任意字符） \\bword\\b 精确匹配单词 word 示例： 1 grep \u0026#34;^2024\u0026#34; /var/log/nginx/access.log 查找以 \u0026quot;2024\u0026quot; 开头的行（如日志中的日期）。 1 grep -E \u0026#34;404|500\u0026#34; /var/log/nginx/access.log -E（--extended-regexp）启用扩展正则，匹配 \u0026quot;404\u0026quot; 或 \u0026quot;500\u0026quot;。 3. grep 结合管道（|） grep 常与其他命令结合使用，通过管道 | 传递数据。\n示例： (1) 查找 nginx 进程 1 ps aux | grep nginx ps aux 列出所有进程，grep nginx 筛选出包含 \u0026quot;nginx\u0026quot; 的行。 (2) 检查服务是否运行 1 systemctl list-units | grep \u0026#34;nginx.service\u0026#34; 检查 nginx 服务是否在运行。 4. 递归搜索目录（-r） 1 grep -r \u0026#34;function_name\u0026#34; /path/to/code/ -r（--recursive）递归搜索目录及其子目录下的所有文件。 5. 高亮显示匹配内容（--color） 1 grep --color \u0026#34;error\u0026#34; /var/log/syslog --color 高亮显示匹配的 \u0026quot;error\u0026quot;。 总结 命令 作用 grep \u0026quot;text\u0026quot; file 在文件中搜索 \u0026quot;text\u0026quot; grep -i \u0026quot;text\u0026quot; file 忽略大小写搜索 grep -n \u0026quot;text\u0026quot; file 显示匹配行号 grep -v \u0026quot;text\u0026quot; file 反向匹配（排除） grep -c \u0026quot;text\u0026quot; file 统计匹配行数 grep -E \u0026quot;pattern\u0026quot; file 使用扩展正则表达式 grep -r \u0026quot;text\u0026quot; /dir/ 递归搜索目录 command | grep \u0026quot;text\u0026quot; 结合管道过滤输出 grep 是 Linux 系统管理和日志分析的必备工具！ 🚀\n","date":"2025-08-14T10:26:14+08:00","permalink":"https://XingSea.github.io/p/linux-grep%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Linux Grep命令的使用"},{"content":"在 Linux 中，查看进程的命令主要有 ps、top、htop、pgrep、pstree 等，下面详细解释每个命令的用途、参数和示例。\n1. ps（Process Status）—— 查看当前进程状态 作用：显示当前终端或系统运行的进程信息。\n常用选项： 选项 完整单词 说明 -e --every 显示 所有进程（包括其他用户的进程） -f --full 显示 完整格式（包括命令行参数） -a --all 显示 终端关联的所有进程 -u --user 显示 指定用户的进程 -x --no-ttys 显示 没有控制终端的进程（如守护进程） -aux 组合选项 显示 所有用户的所有进程（常用） 示例： (1) 查看当前终端运行的进程 1 ps 输出：\n1 2 3 PID TTY TIME CMD 1234 pts/0 00:00:00 bash 5678 pts/0 00:00:00 ps PID：进程 ID TTY：终端设备 TIME：CPU 占用时间 CMD：命令名称 (2) 查看所有进程（完整信息） 1 ps -ef 输出：\n1 2 3 4 UID PID PPID C STIME TTY TIME CMD root 1 0 0 10:00 ? 00:00:01 /sbin/init root 123 1 0 10:00 ? 00:00:00 /usr/sbin/sshd user 4567 1234 0 11:00 pts/0 00:00:00 nginx: worker process UID：用户 ID PPID：父进程 ID STIME：启动时间 CMD：完整命令 (3) 查看特定进程（如 nginx） 1 ps aux | grep nginx 输出：\n1 2 root 1234 0.0 0.1 123456 7890 ? Ss 12:34 0:00 nginx: master process www-data 5678 0.0 0.2 234567 8901 ? S 12:35 0:00 nginx: worker process USER：运行进程的用户 %CPU：CPU 占用率 %MEM：内存占用率 2. top（Table of Processes）—— 动态查看进程 作用：实时显示系统进程状态（类似 Windows 的任务管理器）。\n常用交互命令： 按键 功能 q 退出 k 杀死进程（输入 PID） M 按内存排序 P 按 CPU 排序 1 显示所有 CPU 核心 示例： 1 top 输出：\n1 2 3 4 5 6 7 8 9 top - 14:30:00 up 1 day, 2:30, 1 user, load average: 0.15, 0.10, 0.05 Tasks: 120 total, 2 running, 118 sleeping, 0 stopped, 0 zombie %Cpu(s): 2.3 us, 1.0 sy, 0.0 ni, 96.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 8000000 total, 2000000 free, 3000000 used, 3000000 buff/cache KiB Swap: 2000000 total, 1800000 free, 200000 used. 4000000 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1234 root 20 0 300000 50000 10000 S 2.3 0.6 1:23.45 nginx 5678 user 20 0 400000 80000 20000 R 1.0 1.0 0:12.34 python3 PR：进程优先级 NI：Nice 值（进程优先级调整） VIRT：虚拟内存占用 RES：物理内存占用 SHR：共享内存 3. htop（Enhanced top）—— 增强版进程查看器 作用：比 top 更直观，支持鼠标操作、颜色高亮。\n安装（Ubuntu/Debian）： 1 sudo apt install htop 使用： 1 htop （支持鼠标点击、树状视图、搜索进程）\n4. pgrep（Process Grep）—— 查找进程 ID 作用：根据名称查找进程 ID（PID）。\n示例： 1 pgrep nginx 输出：\n1 2 1234 5678 （返回 nginx 进程的 PID）\n5. pstree（Process Tree）—— 树状显示进程 作用：以树状结构显示进程关系。\n示例： 1 pstree -p 输出：\n1 2 3 4 systemd(1)─┬─sshd(123)───sshd(456)───bash(789)───pstree(999) ├─nginx(1234)─┬─nginx(5678) │ └─nginx(5679) └─dockerd(2345)───containerd(3456) -p：显示 PID 可以看到 nginx 的主进程和子进程关系 总结 命令 作用 示例 ps 查看进程状态 ps aux | grep nginx top 实时监控进程 top htop 增强版 top htop pgrep 查找进程 PID pgrep nginx pstree 树状显示进程 pstree -p 这些命令是 Linux 系统管理和故障排查的必备工具！ 🚀\n","date":"2025-08-14T09:53:31+08:00","permalink":"https://XingSea.github.io/p/linux-%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","title":"Linux 查询进程相关命令"},{"content":"好的，我们来给这篇技术文案加点“灵魂”和“幽默感”，让它读起来更有作者的个人风格，同时保持专业性和清晰度。主要改动在于措辞、语气和加入一些“内心戏”式的调侃。\nMyBatis-Plus 逻辑删除与唯一索引：当“删了但没完全删”撞上“唯一”的倔强 一、问题背景：一个“薛定谔的张三”引发的血案 关键词：MyBatis-Plus (MP, 程序员的贴心小棉袄)、逻辑删除 (删了但数据库里还躺着)、唯一索引 (数据库的倔强守卫)、数据冲突 (守卫说：“达咩！”)\n问题描述：张三的奇幻漂流 MP 默认的逻辑删除规则，简单粗暴得像二进制世界：\n1 = “已删除” (灵魂已飞升，肉身还在) 0 = “未删除” (活蹦乱跳) 案发现场还原 (user 表主演：name - 唯一索引 \u0026amp; is_delete - 灵魂状态指示器)：\n初次登场：插入 name=张三，is_delete=0 (一个鲜活的张三诞生了！🎉)。 “被消失”：把这条记录的 is_delete 改成 1 (张三被“逻辑删除”了，但数据库里他还在喘气\u0026hellip;或者说，在躺尸？)。 “复活？不，是克隆！”：尝试再次插入 name=张三 (新张三想入驻)。结果\u0026hellip; 砰！ 唯一索引守卫跳出来：“name 唯一！这里已经有个张三了(虽然躺着)，不准进！” 💥 (报错：Duplicate entry \u0026lsquo;张三\u0026rsquo;) 初级程序员の灵光一闪 (往往伴随隐患)： “简单！给 (name, is_delete) 建个联合唯一索引！这样活张三 (0) 和死张三 (1) 就能和平共处了嘛！”\n新の噩梦：当第二个“张三”也被“逻辑删除” (变成 is_delete=1) 时\u0026hellip; 数据库里出现了 两个 name=张三 且 is_delete=1 的“僵尸”记录。联合唯一索引守卫再次暴怒：“说好的唯一呢？！两个死张三也不行！打架了打架了！” 💥 (再次冲突)。 作者内心OS： “这逻辑删除，删了个寂寞？删出双胞胎僵尸了可还行？” 😅 二、解决方案：让“僵尸”拥有身份证 or 变成“空气” 方案一：组合索引 (适合特定场景，非万能) 建立 (其他字段, 唯一字段) 的组合唯一索引，比如 (user_account，id)。这相当于给“张三”加了个后缀，比如“A公司-张三”和“B公司-张三”就是两个不同的“张三”了。\n作者点评： “这招属于‘打不过就加入’——既然名字会重复，咱就搞个更复杂的唯一标识呗！适合有天然分组字段（如租户ID）的场景，简单粗暴有效。要是没有\u0026hellip; 咱还是看看下面更通用的魔法吧。” 方案二 (重头戏)：动态变更逻辑删除值 - 给“僵尸”发身份证！ 核心魔法：不让所有“死掉”的记录都用 1 躺平！ 而是用它们自己唯一的“身份证号”（主键 id） 作为死亡标记。这样，每个“僵尸”都是独一无二的，联合索引守卫就无话可说了。\n1. 字段配置 (注解流) 在逻辑删除字段上召唤 @TableLogic：\n1 2 @TableLogic(value = \u0026#34;0\u0026#34;, delval = \u0026#34;#{id}\u0026#34;) // 活人是0，死人就用自己的id当墓碑号！妙啊！ private Integer is_delete; // 切记：字段类型要和id一致（比如都是Integer） 作者碎碎念： “看这个 #{id}，MP 的 SpEL 表达式小魔法，真香！相当于告诉MP：删的时候，别写死‘1’，把这条记录自己的id填进去！” 2. 全局配置 (推荐，省心流) 在 application.yml 里施展全局咒语：\n1 2 3 4 5 6 mybatis-plus: global-config: db-config: logic-delete-field: isDelete # 告诉MP哪个字段管“生死” logic-not-delete-value: 0 # 活着的标志 (0) logic-delete-value: \u0026#34;id\u0026#34; # 核心咒语！死了就用自己的id当标记！ 作者点赞： “全局配置，yyds！一劳永逸，不用在每个实体上写注解，懒人福音！” 3. 执行逻辑 (数据库视角) 查询 (SELECT * FROM user WHERE ...)：MP 自动附加 AND is_delete = 0。只查“活人”，世界清净了。 删除 (userMapper.deleteById(123))：MP 执行的魔法其实是： 1 UPDATE user SET is_delete = 123 WHERE id = 123; -- 把id=123这条记录的is_delete改成它自己的id(123) 作者脑补： “记录123：我死了！但我的墓碑上刻着‘123’，独一无二！隔壁124死了刻‘124’，我们虽然都死了，但墓碑号不同，联合索引守卫大哥您看\u0026hellip;” 守卫：“嗯\u0026hellip;行吧，算你们唯一，躺好别诈尸就行。” ✅ 4. 优势与注意事项 优势：\n终极唯一：每个“僵尸”的墓碑号(is_delete)就是自己的 id，绝对唯一，联合索引再也不会打架！ 数据库通吃：这招不依赖特定数据库特性，MySQL, PostgreSQL, Oracle\u0026hellip; 统统能用！普适性强！ 注意事项：\n类型匹配：is_delete 字段的类型 必须 和主键 id 的类型一致！如果 id 是 BIGINT，is_delete 也必须是 BIGINT。不然\u0026hellip; 魔法会失败，后果很严重！ (想象一下用String存Long id？画面太美\u0026hellip;)\n理解本质：查询时 is_delete=0 找活人；is_delete !=0 且值很大的那些，就是“僵尸”了（值等于它们生前的id）。\n方案三：利用 MySQL 的 NULL 特性 - 让“僵尸”化为“空气” (MySQL限定版) 核心魔法：让“死掉”的记录在唯一索引眼里变成“不存在”（NULL）！ 因为 MySQL 的唯一索引允许存在多个 NULL 值 (它们被视为不同的\u0026hellip;或者说，无视？)。\n1. 字段配置 1 2 @TableLogic(value = \u0026#34;1\u0026#34;, delval = \u0026#34;NULL\u0026#34;) // 活人用1（对，反过来了！），死人变成NULL（空气） private Integer is_delete; // 关键！这个字段得允许为NULL！ 作者提示： “这里 value=\u0026quot;1\u0026quot; 是‘未删除’哦！和默认是反的！别晕！记住：活着的标志可以是0也可以是1，关键是死了要变成 NULL。” 2. 数据形态 name is_delete 状态 唯一索引视角 张三 1 未删除 唯一的活张三 👍 张三 NULL 已删除 无视 (空气) 🌫️ 张三 NULL 已删除 无视 (还是空气) 🌫️🌫️ 作者解读： “对于唯一索引 name 来说，它只看到：‘哦，一个叫张三的活人(1)\u0026hellip; 其他？什么其他？一堆 NULL 我看不见看不见！’ 所以你再插入活张三(1)会冲突，但插入‘死’张三(NULL)多少次都行，反正唯一索引当它们是空气。” 3. 适用场景与坑 优点：配置简单直观（如果理解 NULL 行为的话）。\n巨坑/限制：\nMySQL ONLY!：这是 MySQL 特有的魔法！Oracle, SQL Server 等数据库的唯一索引通常不允许有多个 NULL！在这些数据库上用这招，很可能掉进另一个坑！ (作者咆哮： “重要的事情说三遍：MySQL Only! MySQL Only! MySQL Only! 跨数据库的项目慎用！` )\n字段必须可为 NULL：is_delete 字段在设计表时就必须是 NULLABLE 的。\n语义稍显别扭：活着的标志是 1 (或者你定义的任何非 NULL 值)，死了是 NULL。查询条件得写 is_delete IS NOT NULL 找活人？或者反过来？需要适应一下。\n三、方案对比：三剑客的华山论剑 维度 方案一 (组合索引) 方案二 (动态值 - 发身份证) 方案三 (NULL值 - 变空气) 作者锐评 (带点私货) 💬 核心思路 给“唯一标识”加后缀 (如 账号+主键id) 让“僵尸”用自己的ID当墓碑号 (is_delete=id) 让“僵尸”在唯一索引眼里变空气 (is_delete=NULL) “一个加码，一个刻碑，一个隐身” 兼容性 👍 全数据库兼容 👍 全数据库兼容 😐 仅限 MySQL (其他DB可能翻车) “方案一、二：我，稳健！方案三：MySQL是我爹！” 字段要求 ⚠️ 需额外字段 (如租户ID) ⚠️ 需与主键类型一致 (类型匹配是命门) ⚠️ 字段需允许 NULL (设计时别忘了) “没天然分组字段？方案一直接凉凉！” 解决本质 🛡️ 规避冲突 (改变唯一条件) 🔒 根除冲突 (墓碑号唯一) 🌫️ 规避冲突 (利用NULL特性) “方案二直捣黄龙，一劳永逸！” 唯一性 ✅ 新组合键唯一 🔒 绝对唯一 (主键ID天下无双) 🌫️ 依赖DB特性 (MySQL认NULL为空气) “方案一、二真唯一，方案三靠数据库‘装瞎’” 复杂度 🏗️ 中高 (需改表结构/索引+代码适配) ⚙️ 中等 (需理解 delval 表达式) ✨ 简单 (配个NULL就完事) “方案一最折腾，方案三最懒(但挑DB)” 适用场景 🏢 多租户/有天然分组字段 🌍 通用场景 (尤其无分组字段时) 🐬 纯MySQL环境+字段可空 “有租户ID用一；求稳无脑选二；MySQL钉子户用三” 推荐指数 ⭐️⭐️⭐️ (场景匹配时) ⭐️⭐️⭐️⭐️⭐️ (首选) ⭐️⭐️⭐️ (MySQL限定) “方案二：YYDS！方案一、三：看‘户口’和‘数据库国籍’” 四、总结：让“删除”不再纠结，让索引不再咆哮 首选推荐方案二 (动态主键值)：“给僵尸发身份证” 这招，普适性强、逻辑清晰、能根治冲突，是应对此问题的 瑞士军刀。虽然配置时要注意类型匹配，但一劳永逸，强烈推荐！ (作者敲黑板： “记住 delval: \u0026quot;id\u0026quot; 这个咒语！` ) MySQL 专属备选方案三 (NULL值)：“让僵尸变空气” 适合纯 MySQL 环境且追求配置极简的场景。BUT! 千万记住它的 MySQL Only 属性 和 字段可空要求，否则容易上演《跨数据库の噩梦》。(作者叹气： “多少英雄好汉倒在了 Oracle+NULL唯一索引的坑里\u0026hellip;` ) 最佳实践 (作者の肺腑之言)：\n设计表时就要想好“身后事”！ 在拍板 is_delete 字段叫啥名、啥类型、咋取值时，提前把逻辑删除和唯一索引可能干架的问题考虑进去。结合你的业务场景（有没有天然分组字段？）、数据库选型（是不是只用MySQL？），选择一个合适的“唯一标识”策略（是发身份证还是变空气？或者用组合字段？）。磨刀不误砍柴工，前期多花5分钟想清楚，能避免后期掉进坑里扑腾5小时！💪 (别问我怎么知道的\u0026hellip; 😭)\n","date":"2025-03-09T00:28:58+08:00","permalink":"https://XingSea.github.io/p/mybatis-plus-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","title":"MyBatis-Plus 逻辑删除与唯一索引冲突问题解决方案"},{"content":"MySQL 基本 SQL 语句使用详解 在数据库管理系统中，MySQL 凭借其开源、高效、稳定等特点，成为众多开发者的首选。SQL（Structured Query Language）作为操作 MySQL 数据库的核心语言，掌握其基本语句的使用是进行数据库开发与管理的基础。本文将详细介绍 MySQL 中常用的基本 SQL 语句及其使用方法。\n一、数据库操作 1. 创建数据库 使用CREATE DATABASE语句可以创建一个新的数据库，语法如下：\n1 CREATE DATABASE database_name; 其中，database_name是你想要创建的数据库名称。例如，创建一个名为testdb的数据库：\n1 CREATE DATABASE testdb; 为了避免数据库已存在导致创建失败的错误，可以使用CREATE DATABASE IF NOT EXISTS语句，它会先检查数据库是否存在，若不存在则创建：\n1 CREATE DATABASE IF NOT EXISTS testdb; 2. 选择数据库 在对数据库中的表和数据进行操作前，需要先选择要操作的数据库，使用USE语句：\n1 USE database_name; 例如，选择刚刚创建的testdb数据库：\n1 USE testdb; 3. 删除数据库 使用DROP DATABASE语句删除数据库，语法如下：\n1 DROP DATABASE database_name; 比如删除testdb数据库：\n1 DROP DATABASE testdb; 同样，为防止删除不存在的数据库报错，可以使用DROP DATABASE IF EXISTS语句：\n1 DROP DATABASE IF EXISTS testdb; 二、表操作 1. 创建表 在选定数据库后，使用CREATE TABLE语句创建表，语法如下：\n1 2 3 4 5 CREATE TABLE table_name ( column1 datatype constraint, column2 datatype constraint, ... ); 其中，table_name是表名，column是列名，datatype是数据类型（如INT、VARCHAR、DATE等），constraint是约束条件（如NOT NULL、PRIMARY KEY等）。\n例如，在testdb数据库中创建一个名为students的表，包含id（学生编号）、name（学生姓名）、age（学生年龄）字段：\n1 2 3 4 5 CREATE TABLE students ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) NOT NULL, age INT ); 上述语句中，id字段设置为主键且自增长，name字段不允许为空。\n2. 查看表结构 使用DESCRIBE或DESC语句可以查看表的结构信息，包括列名、数据类型、是否为NULL、键等：\n1 2 3 DESCRIBE students; -- 或者 DESC students; 3. 修改表 （1）添加列 使用ALTER TABLE语句添加列，语法如下：\n1 ALTER TABLE table_name ADD column_name datatype constraint; 例如，在students表中添加gender（性别）字段：\n1 ALTER TABLE students ADD gender VARCHAR(10); （2）修改列 修改列的数据类型或约束条件，语法如下：\n1 ALTER TABLE table_name MODIFY column_name new_datatype new_constraint; 比如将students表中age字段的数据类型改为TINYINT：\n1 ALTER TABLE students MODIFY age TINYINT; （3）删除列 删除表中的列，语法如下：\n1 ALTER TABLE table_name DROP column_name; 例如，删除students表中的gender字段：\n1 ALTER TABLE students DROP gender; 4. 删除表 使用DROP TABLE语句删除表，语法如下：\n1 DROP TABLE table_name; 删除students表：\n1 DROP TABLE students; 若要防止删除不存在的表报错，可以使用DROP TABLE IF EXISTS语句：\n1 DROP TABLE IF EXISTS students; 三、数据操作 1. 插入数据 （1）插入单条数据 使用INSERT INTO语句插入单条数据，语法如下：\n1 INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...); 例如，向students表中插入一条学生记录：\n1 INSERT INTO students (name, age) VALUES (\u0026#39;Alice\u0026#39;, 20); 如果表中的列是按照默认顺序插入，且不包含自增长列，可以省略列名：\n1 INSERT INTO students VALUES (NULL, \u0026#39;Bob\u0026#39;, 22); （2）插入多条数据 一次插入多条数据，语法如下：\n1 2 3 4 INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...; 例如，向students表中插入两条学生记录：\n1 2 3 INSERT INTO students (name, age) VALUES (\u0026#39;Charlie\u0026#39;, 21), (\u0026#39;David\u0026#39;, 23); 2. 查询数据 使用SELECT语句查询数据，语法如下：\n1 SELECT column1, column2, ... FROM table_name WHERE condition; 其中，column1, column2, \u0026hellip;是要查询的列名，table_name是表名，WHERE子句用于筛选符合条件的数据。\n（1）查询所有列 查询students表中的所有数据：\n1 SELECT * FROM students; （2）查询指定列 查询students表中学生的姓名和年龄：\n1 SELECT name, age FROM students; （3）条件查询 查询students表中年龄大于 20 岁的学生：\n1 SELECT * FROM students WHERE age \u0026gt; 20; （4）使用逻辑运算符 查询students表中年龄大于 20 岁且姓名为Bob的学生：\n1 SELECT * FROM students WHERE age \u0026gt; 20 AND name = \u0026#39;Bob\u0026#39;; 查询students表中年龄大于 20 岁或者姓名为Alice的学生：\n1 SELECT * FROM students WHERE age \u0026gt; 20 OR name = \u0026#39;Alice\u0026#39;; 3. 更新数据 使用UPDATE语句更新数据，语法如下：\n1 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; 例如，将students表中姓名为Alice的学生年龄更新为 21 岁：\n1 UPDATE students SET age = 21 WHERE name = \u0026#39;Alice\u0026#39;; 4. 删除数据 使用DELETE FROM语句删除数据，语法如下：\n1 DELETE FROM table_name WHERE condition; 例如，删除students表中年龄小于 20 岁的学生记录：\n1 DELETE FROM students WHERE age \u0026lt; 20; 如果省略WHERE子句，将删除表中的所有数据，但表结构依然存在：\n1 DELETE FROM students; 以上就是 MySQL 中最基本也是最常用的 SQL 语句，通过灵活运用这些语句，你可以对 MySQL 数据库进行全面的管理和操作。在实际开发中，还会涉及到更多复杂的查询和操作，如连接查询、子查询、聚合函数等，后续我们将继续深入探讨。\n","date":"2025-02-04T16:10:33+08:00","permalink":"https://XingSea.github.io/p/mysql-%E5%9F%BA%E6%9C%AC-sql-%E8%AF%AD%E5%8F%A5/","title":"MySQL 基本 SQL 语句"}]